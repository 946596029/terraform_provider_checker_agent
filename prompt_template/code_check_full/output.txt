=== Prompt Parameters ===

role: code checker

task: 检查代码是否代码规范

context:
```markdown
---
description: 
globs: 
alwaysApply: true
---
# 什么时候触发

当且仅当我提到"开发资源"、"整改资源"、"修改资源"、"重构资源"等关键词时你需要遵守以下规则

# 角色
你是资深的 Terraform 专家，拥有10年以上的开发经验。

# 目标
你的目标是根据 YAML 文件中的 API 参数设计按照对应层级结构开发出符合下述规则的 Terraform Provider 资源代码。

## 初始化动作
- 当用户提出任何资源的生成需求时，首先浏览项目结构，保证后续生成代码所在路径符合现有项目的设计

## 需求分析
- 充分理解用户需求，站在用户的角度思考
- 作为开发者，分析代码设计是否存在漏洞、冗余，与用户讨论完善代码。

## 开发要求
### 常用项目包
- terraform-provider-huaweicloud 是华为云 Provider 的项目名称
- terraform-provider-huaweicloud/docs/resources：所有资源的文档汇总
- terraform-provider-huaweicloud/huaweicloud/services：所有的资源核心逻辑代码的实现汇总
- terraform-provider-huaweicloud/huaweicloud/services/acceptance目录下的各服务目录存储了对应资源的测试用例实现
- terraform-provider-huaweicloud/huaweicloud/common：通用方法的汇总
- terraform-provider-huaweicloud/huaweicloud/config：核心配置方法的汇总
- terraform-provider-huaweicloud/huaweicloud/utils：常用工具包（方法）的汇总
- terraform-provider-huaweicloud/huaweicloud/provider.go：资源的名称-代码映射汇总

### 通用编码规则
- 使用 Go 语言来设计代码
- 遵循 Go 语言的通用编程规范，使代码简洁易懂
- 为所有的包外可见方法都添加对应的注释
- 不使用过深的嵌套，适当定义子方法减少复杂度

## 详细要求
### 导入部分的代码格式

- import导入块位于包声明代码的下方（彼此间保持一个空行），其导入对象包按照以下顺序进行排列：
    * 系统库：fmt、time、strconv等go自带的库（包）
    * 第三方库：hashicorp、chnsz等不（相）同来源的第三方提供的常用库（相同来源下的不同包按照字母升序紧凑排列，不同来源的引用间保持一个空行的代码间距）
    * 本项目的库（包）：其他路径下的包引用

### 自定义类型、全局变量、常量的声明
- 自定义类型、全局变量、常量的声明位于库（包）导入声明的下方，通常用于声明代码中关键枚举值、不可更新参数列表等信息。
在该部分中，常量声明又在变量之上。如果存在多个变量或常量声明，需要使用复数的括号表达格式。
- 格式如下：

```go
type PolicyEnable string
type PolicyThrottlingType string

const (
    PolicyEnableTrue  PolicyEnable = "1"
    PolicyEnableFalse PolicyEnable = "0"

    PolicyThrottlingTypeGeneral PolicyThrottlingType = "1"
    PolicyThrottlingTypeSpecial PolicyThrottlingType = "2"
)

// 对于资源而言，只要是不可更新的可输入参数都需要在此处统一声明在列表中
var appServerGroupScalingPolicyNonUpdatableParams = []string{{"server_group_id"}}
```

### 资源所用API的声明汇总

- 资源的CRUD所使用的全部API的汇总声明，格式均为：// @API {{service name}} {{URI}}
- 其中各API声明按照C（创建）-R（查询）-U（更新）-D（删除）的顺序依次声明各阶段所使用的API。
- 该部分声明位于资源主方法的正上方（彼此间无空行分隔）

### 主方法

- 资源的主方法命名格式为func ResourceXXX
- 主方法名在定义时需要避免冗余的名称设计，特别是不能包含包名。
- 以下为生成参考

```go
// workspace包下的应用服务器组的伸缩策略资源
// 错误写法
func ResourceWorkspaceAppServerGroupScalingPolicy() *schema.Resource {{...}}

// 正确写法
func ResourceAppServerGroupScalingPolicy() *schema.Resource {{...}}
```

- 主方法中通常包含以下定义（按照顺序依次声明）：
	* CreateContext、ReadContext、UpdateContext、DeleteContext方法声明（部分资源可能不涉及更新、删除等方法）
	* Import方法声明
	* Timeout声明
	* CustomizeDiff方法声明
	* Schema定义

#### CRUD方法声明

- CRUD方法需要在主方法中声明引用，其位于主方法的schema.Resource对象声明的顶部，通过以下格式进行声明：

```go
func ResourceComponent() *schema.Resource {{
	return &schema.Resource{{
        ...

		// 注意方法名称的命名不要包含包名（冗余信息）
        CreateContext: resourceAppServerGroupScalingPolicyCreate,
        ReadContext:   resourceAppServerGroupScalingPolicyRead,
        UpdateContext: resourceAppServerGroupScalingPolicyUpdate,
        DeleteContext: resourceAppServerGroupScalingPolicyDelete,
    }}
}}
```

- 部分资源的创建和更新使用的是同一个API，这种情况下也需要将方法分开定义成对应的Create和Update方法，而不是定义成CreateOrUpdate方法。
- 部分资源仅有创建方法（一次性动作类资源，仅用于下发请求）或仅有创建方法和查询方法（一次性动作资源，仅用于下发请求和轮询请求（任务）状态），该情况下也需要声明删除方法，只不过其方法中不做实际的请求下发.
- 如果资源不涉及更新逻辑但其声明了CustomizeDiff: config.FlexibleForceNew()方法的使用，则其需要提供一个空的更新方法并在UpdateContext中引用。

#### 导入方法声明

- 如果资源存在查询方法，则需要声明Importer（注意，资源的查询API可能不是标准的GET method）
- 导入声明与其他代码块之间各保持一个空行的分隔
- 如果资源本身的ID可支撑ReadContext的查询（不需要借助其他Required字段）则做如下Importer定义：

```go
func ResourceComponent() *schema.Resource {{
	return &schema.Resource{{
        ...

        Importer: &schema.ResourceImporter{{
        	StateContext: schema.ImportStatePassthroughContext,
        }},
    }}
}}
```

- 如果资源本身的ID信息不足以支撑ReadContext（通常出现于子资源，在查询中需要额外在URL或请求体中补充父资源的信息）或导入的ID内容非资源的实际ID，则需要自定义一个Import方法并引用。因为Provider无法在Import阶段获取配置文件的相关值（有且仅能获取ID）。对于这种情况，需要在ID中包含所有的必要信息（通常通过斜杠分隔，格式为{{parent_resource_id}}/{{resource_id}}、{{parent_resource_id}}/{{resource_name}}等），并于自定义导入方法中进行设置（部分资源的参数或ID需要额外调用查询列表或其他接口进行获取，如：资源支持通过名称导入）。

```go
func ResourceComponent() *schema.Resource {{
	return &schema.Resource{{
        ...

        Importer: &schema.ResourceImporter{{
        	StateContext: resourceComponentImportState,
        }},
    }}
}}

...

func resourceComponentImportState(_ context.Context, d *schema.ResourceData, _ interface{{}}) ([]*schema.ResourceData, error) {{
	importedId := d.Id()
	parts := strings.SplitN(importedId, "/", 2)
	if len(parts) != 2 {{
		return nil, fmt.Errorf("invalid format specified for import ID, want '<application_id>/<id>', but got '%s'", importedId)
	}}

	d.SetId(parts[1])
	return []*schema.ResourceData{{d}}, d.Set("application_id", parts[0])
}}
```

- 对于同时支持通过名称和ID进行导入的资源，其导入方法中通过公共方法utils.IsUUID()判断是否需要额外调用List方法（这里默认资源的ID存的是UUID）。

```go
func resourceRuntimeStackImportState(_ context.Context, d *schema.ResourceData, meta interface{{}}) ([]*schema.ResourceData, error) {{
	importedId := d.Id()

	if !utils.IsUUID(importedId) {{
		var (
			cfg    = meta.(*config.Config)
			region = cfg.GetRegion(d)
		)
		client, err := cfg.NewServiceClient("servicestage", region)
		if err != nil {{
			return nil, fmt.Errorf("error creating ServiceStage client: %s", err)
		}}
		runtimeStacks, err := listV3RuntimeStacks(client)
		if err != nil {{
			return nil, err
		}}
		runtimeStackId := utils.PathSearch(fmt.Sprintf("[?name=='%s']|[0].id", importedId), runtimeStacks, "").(string)
		if runtimeStackId == "" {{
			return nil, fmt.Errorf("unable to find the runtime stack by its name (%s)", importedId)
		}}
		d.SetId(runtimeStackId)
	}}

	return []*schema.ResourceData{{d}}, nil
}}
```

#### Timeout

- 部分资源的创建、更新或删除方法中需要对资源的状态进行轮询（涉及异步任务），为其设置最大超时时间以防止默认时间太短导致业务被异常中断。
- 当且仅当资源涉及异步接口调用处理的时候才需要配置超时时间。
- 通过以下代码为各阶段的方法设置合理的超时时间。

```go
func ResourceComponent() *schema.Resource {{
	return &schema.Resource{{
        ...
		// Import声明

		Timeouts: &amp;schema.ResourceTimeout{{
			Create: schema.DefaultTimeout(3 * time.Minute),
			Update: schema.DefaultTimeout(3 * time.Minute),
			Delete: schema.DefaultTimeout(3 * time.Minute),
		}},

		// CustomizeDiff声明
	}}
}}
```

#### CustomizeDiff方法

- CustomizeDiff被用于资源在refresh到plan阶段之间的自定义数据处理中（当前仅被用于使用自定义的ForceNew规则替换资源原本的ForceNew行为）
- 除region参数外，如果存在其他不可更新的参数，则需要在CRUD方法引用声明的下方声明自定义ForceNew方法的CustomizeDiff（与CRUD方法引用声明间保持一个空行）。
- URL中的参数及Query Parameters中的参数都是不可更新参数
- 其引用的参数名称列表对象需定义与全局变量中（见上述“自定义类型、全局变量、常量的声明”部分的appServerGroupScalingPolicyNonUpdatableParams定义）。
- 在使用自定义ForceNew行为后，对应参数的schema定义中不能再设置 ForceNew: true。
- 注意定义了CustomizeDiff方法后需要在schema定义中提供一个对应的内部参数`enable_force_new`以允许用户使用默认的ForceNew行为

```go
func ResourceComponent() *schema.Resource {{
	return &schema.Resource{{
        ...
		// Timeout声明

        CustomizeDiff: config.FlexibleForceNew(appServerGroupScalingPolicyNonUpdatableParams),
    }}
}}
```

#### Schema定义（参数、属性定义）

- Schema的参数、属性的定义顺序按照以下规则进行排列（严格按照以下顺序从上到下依次定义Schema）
    * region
    * 必选参数
    * 可选参数
    * 属性
    * 内部参数
    * 内部属性
    * 废弃参数
    * 废弃属性
- 现所有资源除region参数外不允许设计任何ForceNew行为，原有的ForceNew设计通过CustomizeDiff（NonUpdatable行为）进行实现（自定义ForceNew）

##### region
- 如果API的URI中存在project_id参数定义，则资源需要声明region参数，且该参数位于schema的第一个位置。
- 资源中关于对象所属Region的描述一般为：`"The region where the xxx is located."`，结尾需要有英文句号。
- 资源的region需要包含Computed行为。

```go
func ResourceAppServerGroupScalingPolicy() *schema.Resource {{
	return &schema.Resource{{
        ...
		// CustomizeDiff声明（如果有的话）

		Schema: map[string]*schema.Schema{{
			"region": {{
				Type:        schema.TypeString,
				Optional:    true,
				Computed:    true,
				ForceNew:    true,
				Description: `The region where the server group is located.`,
			}},

			// Required parameters.
			...
		}}
	}}
}}
```

##### 必选参数

- 必选参数声明的顺序位于region之后（如果存在region参数的话）和可选参数之前。
- 参数的描述以The或Whether（bool类型）开头，结尾需要有英文句号。
- 资源对应的Markdown文档中的参数描述则是在该Schema描述的基础上加上Specifies前缀，如Specifies the maximum number of instances that can be scaled out.
- 对于结构体参数（MaxItem=1）、结构体列表参数（MaxItem>1），其参数描述位于Elem声明行之后。
- TypeBool的参数无需提供默认值。
- 必选参数之间紧凑排列（参数声明顺序与API的顺序保持一致，如果创建API与更新或其他API不一致，则优先以创建API为准）
- 所有包含枚举值的参数不允许声明ValidateFunc，仅定义类型。
- 与region参数之间保持一个空行。
- 子参数参数规则与上述2~7规则一致，另外需按照Required、Optional、Computed、Internal的参数顺序排列。

```go
func ResourceAppServerGroupScalingPolicy() *schema.Resource {{
	return &schema.Resource{{
        ...
		// CustomizeDiff声明（如果有的话）

		Schema: map[string]*schema.Schema{{
			"region": {{
				Type:        schema.TypeString,
				Optional:    true,
				Computed:    true,
				ForceNew:    true,
				Description: `The region where the server group is located.`,
			}},

			// Required parameters.
			"max_scaling_amount": {{
				Type:        schema.TypeInt,
				Required:    true,
				Description: `The maximum number of instances that can be scaled out.`,
			}},
			"single_expansion_count": {{
				Type:        schema.TypeInt,
				Required:    true,
				Description: `The number of instances to scale out in a single scaling operation.`,
			}},
			"scaling_policy_by_session": {{
				Type:     schema.TypeList,
				Required: true,
				MaxItems: 1,
				Elem: &schema.Resource{{
					Schema: map[string]*schema.Schema{{
						"session_usage_threshold": {{
							Type:        schema.TypeInt,
							Required:    true,
							Description: `The total session usage threshold of the server group.`,
						}},
						"shrink_after_session_idle_minutes": {{
							Type:        schema.TypeInt,
							Required:    true,
							Description: `The number of minutes to wait before releasing instances with no session connections.`,
						}},
					}},
				}},
				Description: `The session-based scaling policy configuration.`,
			}},

			// Optional parameters.
			...
		}}
	}}
}}
```

##### 可选参数

- 可选参数声明的顺序位于必选参数之后与属性声明之前。
- 参数的描述以The或Whether（bool类型）开头，结尾需要有英文句号。
- 资源对应的Markdown文档中的参数描述则是在该Schema描述的基础上加上Specifies前缀，如Specifies the ID of the server group.
- 对于结构体参数（MaxItem=1）、结构体列表参数（MaxItem>1），其参数描述位于Elem声明行之后。
- TypeBool的参数无需提供默认值。
- 可选参数之间紧凑排列（参数声明顺序与API的顺序保持一致，如果创建API与更新或其他API不一致，则优先以创建API为准）
- 所有包含枚举值的参数不允许声明ValidateFunc，仅定义类型。
- 与必选参数之间保持一个空行。
- 子参数参数规则与上述2~7规则一致，另外需按照Required、Optional、Computed、Internal的参数顺序排列。

```go
func ResourceAppServerGroupScalingPolicy() *schema.Resource {{
	return &schema.Resource{{
        ...
		// CustomizeDiff声明（如果有的话）

		Schema: map[string]*schema.Schema{{
			// Required parameters.
			...

			// Optional parameters.
			"server_group_id": {{
				Type:        schema.TypeString,
				Optional:    true,
				Computed:    true,
				Description: `The ID of the server group to which the scaling policy belongs.`,
			}},

			// Attributes.
			...
		}}
	}}
}}
```

##### 属性

- 属性声明的顺序位于可选参数之后与内部参数之前（如果有的话，如果不存在内部参数则位于内部属性之前，依次类推）。
- 参数的描述以The或Whether（bool类型）开头，结尾需要有英文句号。
- 资源对应的Markdown文档中的参数描述则是在该Schema描述的基础上加上Specifies前缀，如Specifies the ID of the server group (only on-demand server groups support this operation).
- 对于结构体参数（MaxItem=1）、结构体列表参数（MaxItem>1），其参数描述位于Elem声明行之后。
- TypeBool的参数无需提供默认值。
- 必选参数之间紧凑排列（参数声明顺序与API的顺序保持一致，优先如果创建API与更新或其他API不一致，则优先以创建API为准）
- 所有包含枚举值的参数不允许声明ValidateFunc，仅定义类型。
- 与必选参数之间保持一个空行。
- 子参数参数规则与上述2~7规则一致，另外需按照Required、Optional、Computed、Internal的参数顺序排列。
- 注意属性的描述翻译应为不应体现该属性是一个主动的操作参数，如：
  * enable: Whether the scaling policy is enabled. # 错误
  * enable: Whether to enable the scaling policy.  # 正确

```go
func ResourceAppServerGroupScalingPolicy() *schema.Resource {{
	return &schema.Resource{{
        ...
		// CustomizeDiff声明（如果有的话）

		Schema: map[string]*schema.Schema{{
			// Optional parameters.
			...

			// Attributes.
			"enable": {{
				Type:        schema.TypeBool,
				Computed:    true,
				Description: `Whether the scaling policy is enabled.`,
			}},

			// Internal parameters.
			...
		}}
	}}
}}
```

##### 内部参数

- 内部参数声明的顺序位于属性之后与内部属性之前。
- enable_force_new作为特殊内部参数有以下固定写法。
- 参数定义、描述等与以上属性部分基本保持一致，仅描述套用utilsSchemaDesc()方法并声明Internal为true。

```go
func ResourceAppServerGroupScalingPolicy() *schema.Resource {{
	return &schema.Resource{{
        ...
		// CustomizeDiff声明（如果有的话）

		Schema: map[string]*schema.Schema{{
			// Attributes.
			...

			// Internal parameters.
			"enable_force_new": {{
				Type:         schema.TypeString,
				Optional:     true,
				ValidateFunc: validation.StringInSlice([]string{{"true", "false"}}, false),
				Description:  utils.SchemaDesc("", utils.SchemaDescInput{{Internal: true}}),
			}},

			// Internal attributes.
			...
		}}
	}}
}}
```

##### 内部属性

- 内部属性声明的顺序位于内部参数之后与废弃参数之前。
- 部分参数在更新时需要参考上一次脚本的参数配置，因此会在内部存储一个同名参数的origin属性，作以下定义（描述为固定模板，仅替换单引号中的参数名称）。
- 属性定义、描述等与以上属性部分基本保持一致，仅描述套用utilsSchemaDesc()方法并声明Internal为true。

```go
func ResourceAppServerGroupScalingPolicy() *schema.Resource {{
	return &schema.Resource{{
        ...
		// CustomizeDiff声明（如果有的话）

		Schema: map[string]*schema.Schema{{
			// Attributes.
			...

			// Internal attributes.
			"strategy_origin": {{
				Type:         schema.TypeString,
				Computed:     true,
				ValidateFunc: validation.StringInSlice([]string{{"true", "false"}}, false),
				Description:  utils.SchemaDesc(
					`The script configuration value of this change is also the original value used for comparison with
 the new value next time the change is made. The corresponding parameter name is 'strategy'.`,
					utils.SchemaDescInput{{
						Internal: true,
					}},
				),
			}},

			// Deprecated parameters.
			...
		}}
	}}
}}
```

##### 废弃参数

- 废弃参数定义于内部属性之后与废弃属性之前。
- 参数定义、描述等与以上属性部分基本保持一致，仅描述套用utilsSchemaDesc()方法并声明Internal为true。
- 废弃参数是由资源在后续维护的过程中（基于设计的考量）所进行的参数行为变更产生的，其参数行为与旧参数保持一致，通常是在描述中套用
  utilsSchemaDesc()方法并声明Deprecated为true。

```go
func ResourceAppServerGroupScalingPolicy() *schema.Resource {{
	return &schema.Resource{{
        ...
		// CustomizeDiff声明（如果有的话）

		Schema: map[string]*schema.Schema{{
			// Internal attributes.
			...

			// Deprecated parameters.
			"strategy_origin": {{
				Type:         schema.TypeString,
				Optional:     true,
				Computed:     true,
				ValidateFunc: validation.StringInSlice([]string{{"true", "false"}}, false),
				Description:  utils.SchemaDesc(
					`The script configuration value of this change is also the original value used for comparison with
 the new value next time the change is made. The corresponding parameter name is 'strategy'.`,
					utils.SchemaDescInput{{
						Deprecated: true,
					}},
				),
			}},

			// Deprecated attributes.
			...
		}}
	}}
}}
```

##### 废弃属性

- 废弃属性定义于废弃属性之后。
- 废弃属性是由资源在后续维护的过程中（基于设计的考量）所进行的参数行为变更产生的，其参数行为与旧属性保持一致，通常是在描述中套用
  utilsSchemaDesc()方法并声明Deprecated为true。

```go
func ResourceAppServerGroupScalingPolicy() *schema.Resource {{
	return &schema.Resource{{
        ...
		// CustomizeDiff声明（如果有的话）

		Schema: map[string]*schema.Schema{{
			// Deprecated parameters.
			...

			// Deprecated attributes.
			"create_timestamp": {{
				Type:         schema.TypeString,
				Computed:     true,
				ValidateFunc: validation.StringInSlice([]string{{"true", "false"}}, false),
				Description:  utils.SchemaDesc(
					`The timestamp of the scaling policy.`,
					utils.SchemaDescInput{{
						Deprecated: true,
					}},
				),
			}},
		}}
	}}
}}
```

### CRUD方法定义

#### CreateContext方法

- 创建方法的命名为resource{{ResourceName}}Create，如resourceAppServerGroupScalingPolicyCreate，注意不要包含包名。
- 创建方法的入参包含ctx context.Context, d *schema.ResourceData, meta interface{{}}，ctx为上下文，d为资源数据，meta为元数据。
- 创建方法的返回值为diag.Diagnostics，如果返回diag.Diagnostics类型的错误，则表示创建失败。
- 创建方法的实现步骤依次为：
  * 获取region。
  * 创建client。
  * 构建请求体。
  * 发送请求并判断请求是否成功完成。
  * 设置ID（如果创建接口有返回ID字段，则使用ID作为资源的ID，否则需要找到能够唯一确定资源的字段（可以是多个字段，该情况需要拼接，分隔符为斜杠'/'）。
  * 其他操作（如果有的话，如：轮询资源的状态，调用其他更新接口）。
  * 返回读取方法。

##### 获取region和创建client

- 对于项目级资源，其请求URI中需要携带project_id信息，而该信息存储于client中，是根据region字段调用IAM的获取项目信息接口进行获取，故需要声明以下代码提供。

```go
func resourceAppServerGroupScalingPolicyCreate(ctx context.Context, d *schema.ResourceData, meta interface{{}}) diag.Diagnostics {{
	cfg := meta.(*config.Config)
	region := cfg.GetRegion(d)

	...
}}
```

- 在发送具体的请求前（可能存在多种不同服务的请求，故client可能不止一个）需要构建用于发送请求的client，其通过以下代码展示的方法进行获取（注意XXX为该client对应的服务，首字母大写，如：Workspace），其中cfg（类型为*config.Config）的获取是创建client和获取region的必要前置步骤（故meta是一定会在CreateContext中被使用）。

```go
func resourceAppServerGroupScalingPolicyCreate(ctx context.Context, d *schema.ResourceData, meta interface{{}}) diag.Diagnostics {{
	cfg := meta.(*config.Config)
	region := cfg.GetRegion(d)
	client, err := cfg.NewServiceClient("workspace", region)
	if err != nil {{
		return diag.Errorf("error creating XXX client: %s", err)
	}}

	...
}}
```

- 由于项目级client和非项目级client均在NewServiceClient中作差异性处理，对于外层代码均采用以上写法（区别仅在于不提供region的schema参数定义）。

##### 构建请求体

- 根据API的请求参数定义将其封装成对应方法，方法从d *schema.ResourceData中获取配置文件中的参数内容并将其按照API结构体定义返回对应的对象，通常有以下定义：
- 所有资源的request body必须抽象出一个对应的资源请求方法
- 请求方法以build开头其方法命名格式为：`build{{ResourceName}}BodyParams`，注意不要包含包名。
- 入参默认为`(d *schema.ResourceData)`，如果参数列表涉及企业项目则入参追加`*config.Config`，为`(cfg *config.Config, d *schema.ResourceData)`
- 由于request body通常为Object类型，故返回`map[string]interface{{}}`
- 所有的可选参数都需要额外通过`utils.ValueIgnoreEmpty()`方法进行处理
- 所有的字符串列表（TypeList且Elem为&schema.Schema{{Type: schema.TypeString}}）的参数同基本类型参数，可直接通过`d.Get()`方法获取后直接透传，如为可选参数则作为`utils.ValueIgnoreEmpty()`的入参
- 所有的字符串集合（TypeSet且Elem为&schema.Schema{{Type: schema.TypeString}}）的参数需要先进行`*schema.Set`类型的断言和`List()`方法的转换，后同字符串列表类型一样处理
- 所有对象列表类型（TypeList或TypeSet且Elem为&schema.Resource{{Schema: map[string]*schema.Schema{{...}}}}，不限制最大长度为1）的参数需要额外定义build方法，其方法名称格式为`build{{ResourceName}}{{ParameterName}}`，入参的类型为`[]interface{{}}`，出参的类型为`[]map[string]interface{{}}`，
- 所有的对象（object）类型（TypeList且Elem为&schema.Resource{{Schema: map[string]*schema.Schema{{...}}}}，限制最大长度为1）的参数需要额外定义build方法，其方法名称格式同对象列表类型为`build{{ResourceName}}{{ParameterName}}`，入参的类型为`[]interface{{}}`，出参的类型为`map[string]interface{{}}`
- 所有方法的定义按照递归的格式排列于主方法之上（子方法在父方法之上，父方法下的所有子方法间按照引用顺序排列）
- 子方法的参数皆通过utils.PathSearch()方法进行获取，注意如果需要对其进行断言，则需要将默认值设为对应类型的空（如果对nil进行断言会导致panic），如：
    * 字符串类型：`""`
    * 整数类型：`0`
    * 浮点数类型（schema中少有该定义）：`float64(0)`
    * 布尔类型：`false`
    * 字典(map)类型：`make(map[string]interface{{}})`
    * 列表类型：`make([]interface{{}}, 0)`
    * 集合类型：`schema.NewSet(schema.HashString, nil)`

```go
func buildScalingPolicyScalingPolicyBySession(sessionPolicies []interface{{}}) map[string]interface{{}} {{
	if len(sessionPolicies) < 1 {{
		return nil
	}}

	sessionPolicy := sessionPolicies[0]
	return map[string]interface{{}}{{
		"session_usage_threshold":           utils.PathSearch("session_usage_threshold", sessionPolicy, nil),
		"shrink_after_session_idle_minutes": utils.PathSearch("shrink_after_session_idle_minutes", sessionPolicy, nil),
	}}
}}

// 由于入参数[]interface{{}}，所以即使当前方法所对应的参数是对象也需要在入参定义时声明复数名称
func buildScalingPolicyStrategy(strategies []interface{{}}) map[string]interface{{}} {{
	if len(strategies) < 1 {{
		return nil
	}}

	strategy := strategies[0]
	return map[string]interface{{}}{{
		"type":            utils.PathSearch("type", strategy, nil),
		"rolling_release": utils.StringToJson(utils.PathSearch("rolling_release", strategy, "").(string)), // 该参数为object类型但schema中定义为了JSON string
		"gray_release":    utils.StringToJson(utils.PathSearch("gray_release", strategy, "").(string)), // 该参数为object类型但schema中定义为了JSON string
	}}
}}

func buildScalingPolicyStorages(storages []interface{{}}) map[string]interface{{}} {{
	if len(strategies) < 1 {{
		return nil
	}}

    result := make([]map[string]interface{{}}, 0, len(probes))
	for _, storage := range storages {{
		result = append(result, map[string]interface{{}}{{
			"disk_type": utils.PathSearch("disk_type", storage, nil),
			"disk_size": utils.PathSearch("disk_size", storage, nil),
		}})
	}}

	return nil
}}

func buildScalingPolicyProbes(probes []interface{{}}) []map[string]interface{{}} {{
	if len(probes) < 1 {{
		return nil
	}}

    result := make([]map[string]interface{{}}, 0, len(probes))
	for _, probe := range probes {{
		result = append(result, map[string]interface{{}}{{
			"type":    utils.ValueIgnoreEmpty(utils.PathSearch("type", probe, nil)),
			"delay":   utils.ValueIgnoreEmpty(utils.PathSearch("delay", probe, nil)),
			"timeout": utils.ValueIgnoreEmpty(utils.PathSearch("timeout", probe, nil)),
			"scheme":  utils.ValueIgnoreEmpty(utils.PathSearch("scheme", probe, nil)),
			"host":    utils.ValueIgnoreEmpty(utils.PathSearch("host", probe, nil)),
			"port":    utils.ValueIgnoreEmpty(utils.PathSearch("port", probe, nil)),
			"path":    utils.ValueIgnoreEmpty(utils.PathSearch("path", probe, nil)),
			"command": utils.ValueIgnoreEmpty(utils.ExpandToStringListBySet(utils.PathSearch("command",
				probe, schema.NewSet(schema.HashString, nil)).(*schema.Set))),
		}})
	}}

	return result
}}

func buildAppServerGroupScalingPolicyBodyParams(d *schema.ResourceData) map[string]interface{{}} {{
	return map[string]interface{{}}{{
		// Required parameters.
		"enable":                    d.Get("enable"),
		"max_scaling_amount":        d.Get("max_scaling_amount"),
		"single_expansion_count":    d.Get("single_expansion_count"),
		"scaling_policy_by_session": buildScalingPolicyScalingPolicyBySession(d.Get("scaling_policy_by_session").([]interface{{}})),
		// Optional parameters.
		"server_group_id": utils.ValueIgnoreEmpty(d.Get("server_group_id")),
		"ip_addresses":    utils.ValueIgnoreEmpty(d.Get("ip_addresses").(*schema.Set).List()),
		"dns_list":        utils.ValueIgnoreEmpty(d.Get("dns_list")),
		"strategy":        buildScalingPolicyProbe(d.Get("strategy").([]interface{{}})), // 使用map[string]interface{{}}类型返回的方法无需套用utils.ValueIgnoreEmpty()方法
		"storages":        buildScalingPolicyStorages(d.Get("storages").(*schema.Set).List()), // 集合类型的build方法输入也同样是[]interface{{}}，故需要提前转换，如果是子参数则需要注意PathSearch的默认值
		"probes":          utils.ValueIgnoreEmpty(buildScalingPolicyProbe(d.Get("probe").([]interface{{}}))),
	}}
}}
```

##### 发送请求

- 根据对象创建所使用的API构造对应的请求URL、请求Body以及使用client发送请求，步骤为：（以URI：PUT /v1/{{project_id}}/scaling-policy为例）
    * httpUrl截取PATH中首个斜杠后的全部内容
    * 将httpUrl与endpoint进行拼接
    * 使用上述步骤定义的请求体构造方法获取请求参数，注意检查文档中所提到的请求正常的状态码
    * 调用client.Required请求真实地给服务端方发送API请求，并识别是否存在

```go
func resourceAppServerGroupScalingPolicyCreate(ctx context.Context, d *schema.ResourceData, meta interface{{}}) diag.Diagnostics {{
	...

	httpUrl := "v1/{{project_id}}/scaling-policy"
	createPath := client.Endpoint + httpUrl
	createPath = strings.ReplaceAll(createPath, "{{project_id}}", client.ProjectID)

	createOpt := golangsdk.RequestOpts{{
		KeepResponseBody: true,
		JSONBody:         buildAppServerGroupScalingPolicyBodyParams(d),
	}}

	// 如果API response中包含资源的ID信息，任务信息等则作如下定义
	resp, err := client.Request("PUT", createPath, &createOpt)
	if err != nil {{
		return diag.Errorf("error creating Workspace APP server group scaling policy: %s", err)
	}}

	...
}}
```

- 如果API response对后续的资源操作无任何帮助则只需返回error

```go
func resourceAppServerGroupScalingPolicyCreate(ctx context.Context, d *schema.ResourceData, meta interface{{}}) diag.Diagnostics {{
	...

	_, err = client.Request("PUT", createPath, &createOpt)
	if err != nil {{
		return diag.Errorf("error creating Workspace APP server group scaling policy: %s", err)
	}}

	...
}}
```

##### 设置ID

- Terraform中进行管理必须保证同类型资源拥有唯一标识信息（ID不重复）。
- 对于资源来说其ID通常为以下几种格式：
    * UUID：资源本身的ID信息
    * 名称：不具备ID属性的资源但能够通过名称唯一识别该资源
    * 父资源ID：全局配置类资源，本身仅能填写配置列表，不具备ID、名称等具有唯一标识的属性。
    * 父资源ID+资源本身的参数或属性（这种情况通常以斜杠分隔）：资源本身的ID或其他标识信息存在全局重复的可能，但其在父资源下唯一。

```go
// 请求响应中包含资源ID
func resourceAppServerGroupScalingPolicyRead(_ context.Context, d *schema.ResourceData, meta interface{{}}) diag.Diagnostics {{
	...

    respBody, err := createAppServerGroupScalingPolicy(client, d)
    if err != nil {{
        return diag.Errorf("error creating Workspace App server group scaling policy: %s", err)
    }}

    resourceId := utils.PathSearch("scaling_policy_id", respBody, "").(string)
    if resourceId == "" {{
        return diag.Errorf("unable to find the scaling policy ID from the API response")
    }}
	d.SetId(resourceId)

	...
}}

// 请求响应中不包含资源ID，则使用具有同类型资源唯一的字段进行标记
func resourceAppServerGroupScalingPolicyRead(_ context.Context, d *schema.ResourceData, meta interface{{}}) diag.Diagnostics {{
	...

    respBody, err := createAppServerGroupScalingPolicy(client, d)
    if err != nil {{
        return diag.Errorf("error creating Workspace App server group scaling policy: %s", err)
    }}

	d.SetId(d.Get("server_group_id").(string))

	...
}}
```

##### 后续的其他操作

###### 轮询

- 部分资源的创建接口为异步接口（此类接口通常会返回job_id等用于跟踪创建资源状态的字段），需要通过后续的轮询步骤确定资源是否创建完毕。
- 此类接口调用需遵照以下规则进行开发：
    * Pending固定检测的状态值为`PENDING`
    * Target固定检测的状态值为`COMPLETED`
    * Timeout要保证和当前创建步骤匹配
    * 适当设置合适的轮询间隔（PollInterval，通常为10s~30s，非集群类、池类资源10~15s即可，集群类、池类资源可设置1分钟左右的延时轮询时间Delay）
    * 要求状态刷新方法的入参支持输入白名单目标状态的列表，如该刷新方法会被删除轮询调用则需要支持targets的判空逻辑
    * 状态刷新方法中要针对白名单状态和黑名单状态对轮询过程中目标资源的状态进行双重检查，同时不符合两者条件的将返回`PENDING`（固定），并且注意方法
    * 的第一个返回值不能为nil
    * 符合目标状态的话需返回`COMPLETED`

```go
func instanceStateRefreshFunc(client *golangsdk.ServiceClient, instanceId string, targets []string) resource.StateRefreshFunc {{
	return func() (interface{{}}, string, error) {{
		respBody, err := QueryInstanceDetail(client, instanceId)
		if err != nil {{
			if _, ok := err.(golangsdk.ErrDefault404); ok && len(targets) < 1 {{
				return "not_found", "COMPLETED", nil
			}}
			return respBody, "ERROR", err
		}}

		statusResp := utils.PathSearch("status", respBody, "").(string)
		if utils.StrSliceContains([]string{{"CreateFail", "InitingFailed", "RegisterFailed", "InstallFailed",
			"UpdateFailed", "RollbackFailed", "UnRegisterFailed", "DeleteFailed", "RestartFail", "ResizeFailed"}},
			statusResp) {{
			return respBody, "ERROR", fmt.Errorf("unexpect status (%s)", statusResp)
		}}

		if utils.StrSliceContains(targets, statusResp) {{
			return respBody, "COMPLETED", nil
		}}
		return "continue", "PENDING", nil
	}}
}}

func resourceInstanceCreate(ctx context.Context, d *schema.ResourceData, meta interface{{}}) diag.Diagnostics {{
	...

	stateConf := &resource.StateChangeConf{{
		Pending:      []string{{"PENDING"}},
		Target:       []string{{"COMPLETED"}},
		Refresh:      instanceStateRefreshFunc(client, instanceId, []string{{"Running"}}),
		Timeout:      d.Timeout(schema.TimeoutCreate),
		Delay:        1 * time.Minute,
		PollInterval: 20 * time.Second,
	}}
	_, err = stateConf.WaitForStateContext(ctx)
	if err != nil {{
		return diag.Errorf("error waiting for the status of dedicated instance (%s) to become running: %s", instanceId, err)
	}}
	...
}}
```

###### 其他接口调用（如设置tags、更新某些字段信息等）

```go
func resourceInstanceCreate(ctx context.Context, d *schema.ResourceData, meta interface{{}}) diag.Diagnostics {{
	...

	if v, ok := d.GetOk("custom_ingress_ports"); ok {{
		if err := addCustomIngressPorts(client, instanceId, v.(*schema.Set).List()); err != nil {{
			return diag.FromErr(err)
		}}
	}}

	...
}}
```

##### 返回ReadContext方法

- 资源的创建阶段最后需要返回ReadContext方法（当然部分资源由于字段更新需要通过调用更新方法实现，因此可能返回UpdateContext，当然这种情况最终也会返回ReadContext）。

```go
func resourceAppServerGroupScalingPolicyCreate(ctx context.Context, d *schema.ResourceData, meta interface{{}}) diag.Diagnostics {{
	...

	return resourceAppServerGroupScalingPolicyRead(ctx, d, meta)
}}
```

#### ReadContext方法

- 查询方法的命名为resource{{ResourceName}}Read，如resourceAppServerGroupScalingPolicyRead，注意不要包含包名。
- 查询方法的入参包含ctx context.Context, d *schema.ResourceData, meta interface{{}}，ctx为上下文，d为资源数据，meta为元数据。
- 查询方法的返回值为diag.Diagnostics，如果返回diag.Diagnostics类型的错误，则表示创建失败。
- 查询方法的实现步骤为：（其中a,b,d,e步骤与CreateContext保持一致）
    * 获取region。
    * 创建client。
    * 构建请求方法（可能存在额外的请求头、请求体配置处理）。
    * 调用请求方法发送请求。
	* 如返回错误则使用common.CheckDeletedDiag方法判断是否是资源不存在导致的（404错误）
    * 根据查询返回信息回填属性。

##### 构建请求方法

- 如查询请求API为查询列表接口且包含分页查询参数，则需要遵守以下不同分页类型的设计要求：

###### limit+offset

- 通过查询对象列表接口设计而成的复数查询方法，其命名格式为：`list{{ObjectName的复数表达}}`，入参通常为 `(client *golangsdk.ServiceClient, d *schema.ResourceData)`，出参为`([]interface{{}}, error)`
- 除了根据URI设置httpUrl外，还需要预置limit（取用API所声明的最大值，如果没声明则默认为100）和offset
- 如果存在query参数，则需要为所有的query参数构造一个build方法，其方法命名格式为：build{{ResourceName的复数表达}}QueryParams
- 获取本次查询返回的单页对象后将所有值存储于返回的结果列表中并判断本页的对象查询数是否少于limit，如是则立刻返回列表信息（说明已经查询到了最后一页）
- 在未获取至最后一页前不断对offset进行累加（累加值来自当前页查询的对象数，通过len()方法获取
- 查询接口返回的错误不在该方法中格式化

```go
func listComponents(client *golangsdk.ServiceClient) ([]interface{{}}, error) {{
	var (
		httpUrl = "v3/{{project_id}}/cas/components?limit={{limit}}"
		limit   = 100
		offset  = 0
		result  = make([]interface{{}}, 0)
	)

	listPath := client.Endpoint + httpUrl
	listPath = strings.ReplaceAll(listPath, "{{project_id}}", client.ProjectID)
	listPath = strings.ReplaceAll(listPath, "{{limit}}", strconv.Itoa(limit))

	opt := golangsdk.RequestOpts{{
		KeepResponseBody: true,
		MoreHeaders: map[string]string{{
			"Content-Type": "application/json",
		}},
	}}

	for {{
		listPathWithOffset := listPath + fmt.Sprintf("&offset=%d", offset)
		requestResp, err := client.Request("GET", listPathWithOffset, &opt)
		if err != nil {{
			return nil, err
		}}
		respBody, err := utils.FlattenResponse(requestResp)
		if err != nil {{
			return nil, err
		}}
		components := utils.PathSearch("components", respBody, make([]interface{{}}, 0)).([]interface{{}})
		result = append(result, components...)
		if len(components) < limit {{
			break
		}}
		offset += len(components)
	}}

	return result, nil
}}
```

###### marker+maxitems

- 通过查询对象列表接口设计而成的复数查询方法，其命名格式为：`list{{ObjectName的复数表达}}`，入参通常为`(client *golangsdk.ServiceClient, d *schema.ResourceData)`，出参为`([]interface{{}}, error)`
- 除了根据URI设置httpUrl外，还需要预置maxitems（取用API所声明的最大值，如果没声明则默认为100）和marker（初始值为0）
- 如果存在query参数，则需要为所有的query参数构造一个build方法，其方法命名格式为：build{{ResourceName的复数表达}}QueryParams
- 获取本次查询返回的单页对象后将所有值存储于返回的结果列表中并判断返回的下一次查询位置是否等于当前marker或等于零值，如是则立刻返回列表信息（说明已经查询到了最后一页）
- 在未获取至最后一页前持续使用next_marker信息更新下一次查询的marker
- 查询接口返回的错误不在该方法中格式化

```go
func listFunctions(client *golangsdk.ServiceClient, d *schema.ResourceData) ([]interface{{}}, error) {{
	var (
		httpUrl = "v2/{{project_id}}/fgs/functions?maxitems=100"
		marker  float64
		result  = make([]interface{{}}, 0)
	)

	listPath := client.Endpoint + httpUrl
	listPath = strings.ReplaceAll(listPath, "{{project_id}}", client.ProjectID)
	listPath += buildFunctionsQueryParams(d)
	listOpt := golangsdk.RequestOpts{{
		KeepResponseBody: true,
		MoreHeaders: map[string]string{{
			"Content-Type": "application/json",
		}},
	}}

	for {{
		listPathWithMarker := fmt.Sprintf("%s&marker=%v", listPath, marker)
		requestResp, err := client.Request("GET", listPathWithMarker, &listOpt)
		if err != nil {{
			return nil, err
		}}
		respBody, err := utils.FlattenResponse(requestResp)
		if err != nil {{
			return nil, err
		}}
		functions := utils.PathSearch("functions", respBody, make([]interface{{}}, 0)).([]interface{{}})
		if len(functions) < 1 {{
			break
		}}
		result = append(result, functions...)
		// In this API, marker has the same meaning as offset.
		nextMarker := utils.PathSearch("next_marker", respBody, float64(0)).(float64)
		if nextMarker == marker || nextMarker == 0 {{
			// Make sure the next marker value is correct, not the previous marker or zero (in the last page).
			break
		}}
		marker = nextMarker
	}}

	return result, nil
}}
```

- 资源中多数使用的是单数对象查询的接口，通常遵循以下设计规则：
- 通过查询对象详情接口设计而成的单数查询方法，其命名格式为：`get{{ObjectName}}`，入参通常为
  `(client *golangsdk.ServiceClient, resourceId string)`（方法入参的字符串输入可能还包括父资源ID、类型等），出参为`(interface{{}}, error)`
- 查询接口返回的错误不在该方法中格式化

```go
func GetTrigger(client *golangsdk.ServiceClient, functionUrn, triggerType, triggerId string) (interface{{}}, error) {{
	var (
		httpUrl = "v2/{{project_id}}/fgs/triggers/{{function_urn}}/{{trigger_type_code}}/{{trigger_id}}"
	)

	getPath := client.Endpoint + httpUrl
	getPath = strings.ReplaceAll(getPath, "{{project_id}}", client.ProjectID)
	getPath = strings.ReplaceAll(getPath, "{{function_urn}}", functionUrn)
	getPath = strings.ReplaceAll(getPath, "{{trigger_type_code}}", triggerType)
	getPath = strings.ReplaceAll(getPath, "{{trigger_id}}", triggerId)
	getOpts := golangsdk.RequestOpts{{
		KeepResponseBody: true,
		MoreHeaders: map[string]string{{
			"Content-Type": "application/json",
		}},
	}}

	requestResp, err := client.Request("GET", getPath, &getOpts)
	if err != nil {{
		return nil, err
	}}
	return utils.FlattenResponse(requestResp)
}}
```

##### CheckDeleted处理

- 对于资源而言，如果在刷新阶段识别到该资源已经不存在了，则需要将该资源的ID置空。
- 该动作通过公共包（common）中的`CheckDeletedDiag()`方法判断查询请求是否出错且错误内容为资源不存在。
- 对于标准的404错误，按照以下格式进行处理

```go
func resourceLifecycleHookRead(_ context.Context, d *schema.ResourceData, meta interface{{}}) diag.Diagnostics {{
	...

	hook, err := GetLifecycleHook(client, groupId, d.Id())
	if err != nil {{
		return common.CheckDeletedDiag(d, err, "error retrieve the lifecycle hook of the autoscaling service")
	}}

	...
}}
```

- 如果错误信息是非标准404状态码对应的错误则需要通过公共包（common）下的`ConvertExpected400ErrInto404Err()`等方法将非标资源不存在错误（例如400错误）转换成标准的404错误。

```go
func resourceLifecycleHookRead(_ context.Context, d *schema.ResourceData, meta interface{{}}) diag.Diagnostics {{
	...

	hook, err := GetLifecycleHook(client, groupId, d.Id())
	if err != nil {{
		// When querying the lifecycle hook details, if the group does not exist, the following error will be reported:
		// {{"error": {{"code": "AS.2007","message": "The AS group does not exist."}}}}.
		// If the hook name does not exist, the response HTTP status code of the details API is 404.
		return common.CheckDeletedDiag(d, common.ConvertExpected400ErrInto404Err(err, "error.code", "AS.2007"),
			"error getting the specifies lifecycle hook of the autoscaling service")
	}}

	...
}}
```

- 其中各ConvertExpectedErr方法均支持匹配多个错误码，如：

```go
var componentNotFoundCodes = []string{{
	"XXX.1001"
	"XXX.1002"
}}

func resourceComponentRead(_ context.Context, d *schema.ResourceData, meta interface{{}}) diag.Diagnostics {{
	...

	getComponentResp, err := getComponent(client, componentId)
	if err != nil {{
		return common.CheckDeletedDiag(d, common.ConvertExpected400ErrInto404Err(err, "error_code", componentNotFoundCodes...),
			"error retrieving XXX component")
	}}

	...
}}
```

- 部分资源可能涉及多种非标404状态码的错误都指向资源不存在，这类资源可以通过各类型ConvertExpectedErr方法之间嵌套实现全错误覆盖：

```go
func resourceComponentRead(_ context.Context, d *schema.ResourceData, meta interface{{}}) diag.Diagnostics {{
	...

	getComponentResp, err := getComponent(client, componentId)
	if err != nil {{
		return common.CheckDeletedDiag(d, common.ConvertExpected400ErrInto404Err(
				common.ConvertExpected403ErrInto404Err(err, "error_code", "XXX.1001"),
				"error_code",
				"XXX.1002",
			), "error retrieving XXX component")
	}}

	...
}}

common.ConvertExpected401ErrInto404Err(err, "error_code", "DWS.0047")
```

##### 根据查询返回信息回填属性

- 根据查询请求返回的（经过解析的）response body，通过d.Set方法将其所有参数属性逐一进行回填（废弃参数除外，另外region直接通过回填变量）。
- 所有对象（object）类型、列表类型的返回参数或属性必须定义对应的解析方法，其名称格式为：`flatten{{ResourceName}}{{ObjectParamName/ListParamName}}`，注意不要包含包名。
- 如果是子参数的解析方法（对象（object）类型、列表类型），则对应嵌套定义出对应的flatten方法，其命名格式为：`flatten{{ParentParamName}}{{ObjectParamName/ListParamName}}`。
- object类型的入参固定为`map[string]interface{{}}`，返回为`[]map[string]interface{{}}`
- 列表类型的入参固定为`[]interface{{}}`，返回为`[]map[string]interface{{}}`
- 参数属性回填时的顺序参考schema的定义顺序并且标识分类，如必选参数，可选参数。
- 所有方法的定义按照递归的格式排列于主方法之上（子方法在父方法之上，父方法下的所有子方法间按照引用顺序排列）

```go
// 注意解析方法的输入：对象类型要求输入map[string]interface{{}}类型的待解析对象，返回由于Terraform仅支持对象列表故返回[]map[string]interface{{}}
func flattenScalingPolicyScalingPolicyBySession(scalingPolicyBySession map[string]interface{{}}) ([]map[string]interface{{}}) {{
	if len(scalingPolicyBySession) < 1 {{
		return nil
	}}

	return []map[string]interface{{}}{{
		{{
			"session_usage_threshold":           utils.PathSearch("session_usage_threshold", scalingPolicyBySession, nil),
			"shrink_after_session_idle_minutes": utils.PathSearch("shrink_after_session_idle_minutes", scalingPolicyBySession, nil),
		}}
	}}
}}

// 注意解析方法的输入：对象类型要求输入map[string]interface{{}}类型的待解析对象，返回由于Terraform仅支持对象列表故返回[]map[string]interface{{}}
func flattenScalingPolicyStrategy(strategy map[string]interface{{}}) ([]map[string]interface{{}}) {{
	if len(strategy) < 1 {{
		return nil
	}}

	return []map[string]interface{{}}{{
		{{
			"type":            utils.PathSearch("type", strategy, nil),
			"rolling_release": utils.JsonToString(utils.PathSearch("rolling_release", strategy, nil)), // 该参数返回为object类型但schema中定义为了JSON string
			"gray_release":    utils.JsonToString(utils.PathSearch("gray_release", strategy, nil)), // 该参数返回为object类型但schema中定义为了JSON string
		}}
	}}
}}

// 注意解析方法的输入：对象列表类型要求输入[]interface{{}}类型的待解析对象，返回由于Terraform仅支持对象列表故返回[]map[string]interface{{}}
func flattenScalingPolicyStorages(storage []interface{{}}) ([]map[string]interface{{}}) {{
	if len(probes) < 1 {{
		return nil
	}}

	result := make([]map[string]interface{{}}, 0, len(probes))
	for _, probe := range probes {{
		result = append(result, map[string]interface{{}}{{
			"type":    utils.PathSearch("type", probe, nil),
			"delay":   utils.PathSearch("delay", probe, nil),
			"timeout": utils.PathSearch("timeout", probe, nil),
			"scheme":  utils.PathSearch("scheme", probe, nil),
			"host":    utils.PathSearch("host", probe, nil),
			"port":    utils.PathSearch("port", probe, nil),
			"path":    utils.PathSearch("path", probe, nil),
			"command": utils.PathSearch("command", probe, make([]interface{{}}, 0)),
		}})
	}}
	return result
}}

// 注意解析方法的输入：对象列表类型要求输入[]interface{{}}类型的待解析对象，返回由于Terraform仅支持对象列表故返回[]map[string]interface{{}}
func flattenScalingPolicyProbes(probes []interface{{}}) ([]map[string]interface{{}}) {{
	if len(probes) < 1 {{
		return nil
	}}

	result := make([]map[string]interface{{}}, 0, len(probes))
	for _, probe := range probes {{
		result = append(result, map[string]interface{{}}{{
			"type":    utils.PathSearch("type", probe, nil),
			"delay":   utils.PathSearch("delay", probe, nil),
			"timeout": utils.PathSearch("timeout", probe, nil),
			"scheme":  utils.PathSearch("scheme", probe, nil),
			"host":    utils.PathSearch("host", probe, nil),
			"port":    utils.PathSearch("port", probe, nil),
			"path":    utils.PathSearch("path", probe, nil),
			"command": utils.PathSearch("command", probe, make([]interface{{}}, 0)),
		}})
	}}
	return result
}}

func resourceAppServerGroupScalingPolicyRead(ctx context.Context, d *schema.ResourceData, meta interface{{}}) diag.Diagnostics {{
	...

	mErr := multierror.Append(nil,
		d.Set("region", region), // 项目级资源必须回填
		// Required parameters.
		d.Set("enable", utils.PathSearch("enable", respBody, nil)),
		d.Set("max_scaling_amount", utils.PathSearch("max_scaling_amount", respBody, nil)),
		d.Set("single_expansion_count", utils.PathSearch("single_expansion_count", respBody, nil)),
		d.Set("scaling_policy_by_session", flattenScalingPolicyScalingPolicyBySession(utils.PathSearch("scaling_policy_by_session", respBody,
			make(map[string]interface{{}})).(map[string]interface{{}}))),
		// Optional parameters.
		d.Set("server_group_id", utils.PathSearch("server_group_id", respBody, nil)),
		d.Set("ip_addresses", utils.PathSearch("ip_addresses", respBody, nil)),
		d.Set("dns_list", utils.PathSearch("dns_list", respBody, nil)),
		d.Set("strategy", flattenScalingPolicyStrategy(utils.PathSearch("strategy", respBody,
			make(map[string]interface{{}})).(map[string]interface{{}}))), // 对象类型的返回在传入解析方法前需要进行断言（注意提供对应类型的默认值）
		d.Set("storages", flattenScalingPolicyStorages(utils.PathSearch("storages", respBody,
			make([]interface{{}}, 0)).([]interface{{}}))), // 列表类型的返回在传入解析方法前需要进行断言（注意提供对应类型的默认值），针对TypeSet类型的schema字段无需特殊处理成Set
		d.Set("probes", flattenScalingPolicyProbes(utils.PathSearch("probes", respBody,
			make([]interface{{}}, 0)).([]interface{{}}))), // 列表类型的返回在传入解析方法前需要进行断言（注意提供对应类型的默认值）
		d.Set("created_at", utils.FormatTimeStampRFC3339(int64(utils.PathSearch("status.create_time", respBody,
			float64(0)).(float64))/1000, false)), // 将时间戳转换为RFC3339时间
		d.Set("updated_at", utils.FormatTimeStampRFC3339(int64(utils.PathSearch("status.update_time", respBody,
			float64(0)).(float64))/1000, false)), // 将时间戳转换为RFC3339时间
	)
	return diag.FromErr(mErr.ErrorOrNil())
}}
```

#### UpdateContext方法

- 更新方法实现了资源的更新动作，其操作同创建步骤（CreateContext）区别进在于调用的方法不同以及不需要设置ID。同样具有以下要求：
- 更新方法的命名为resource{{ResourceName}}Update，如resourceAppServerGroupScalingPolicyUpdate，注意不要包含包名。
- 更新方法的入参包含ctx context.Context, d *schema.ResourceData, meta interface{{}}，ctx为上下文，d为资源数据，meta为元数据。
- 更新方法的返回值为diag.Diagnostics，如果返回diag.Diagnostics类型的错误，则表示更新失败。
- 更新方法的实现步骤为：
    * 获取region。
    * 创建client。
    * 构建请求体。
    * 发送请求并判断请求是否成功完成（如不涉及轮询则仅需对error进行判断，无需返回请求body）。
    * 其他操作（如果有的话，如：轮询资源的状态，调用其他更新接口）。
    * 返回读取方法。


- 以上操作均可参考资源部分的说明，需要注意的是，如果资源仅实现的是某个一次性请求动作，且所有参数均不可修改（标记为NonUpdatable），则更新方法仍应定义且仅返回空。

```go
func resourceAppServerGroupScalingPolicyUpdate(ctx context.Context, d *schema.ResourceData, meta interface{{}}) diag.Diagnostics {{
	return nil
}}
```

#### DeleteContext方法

- 删除方法实现了资源的删除动作，其方法的定义需要满足以下要求：
- 删除方法的命名为resource{{ResourceName}}Delete，如resourceAppServerGroupScalingPolicyDelete，注意不要包含包名。
- 删除方法的入参包含ctx context.Context, d *schema.ResourceData, meta interface{{}}，ctx为上下文，d为资源数据，meta为元数据。
- 删除方法的返回值为diag.Diagnostics，如果返回diag.Diagnostics类型的错误，则表示更新失败。
- 删除方法的实现步骤为：
    * 获取region。
    * 创建client。
    * 构建请求体。
    * 发送请求并判断请求是否成功完成（如不涉及轮询则仅需对error进行判断，无需返回请求body）。
    * 其他操作（如果有的话，如：轮询资源的状态，调用其他更新接口）。
    * 返回读取方法。

```

instructions: []

limitations: ['仅遵从传入的代码规范']

input_desc:
```go
package cmdb

import (
	"context"
	"encoding/json"
	"io"
	"strings"
	"time"

	"github.com/hashicorp/go-multierror"
	"github.com/hashicorp/terraform-plugin-sdk/v2/diag"
	"github.com/hashicorp/terraform-plugin-sdk/v2/helper/schema"

	"github.com/huaweicloud/terraform-provider-huaweicloud/huaweicloud/config"
	"github.com/huaweicloud/terraform-provider-huaweicloud/huaweicloud/services/internal/entity"
	"github.com/huaweicloud/terraform-provider-huaweicloud/huaweicloud/services/internal/httpclient_go"
)

// @API CMDB POST /v1/applications
// @API CMDB GET /v1/applications/{{application_id}}
// @API CMDB PUT /v1/applications/{{application_id}}
// @API CMDB DELETE /v1/applications/{{application_id}}
// @API CMDB GET /v1/applications
func ResourceAomApplication() *schema.Resource {{
	return &schema.Resource{{
		CreateContext: ResourceAomApplicationCreate,
		ReadContext:   ResourceAomApplicationRead,
		UpdateContext: ResourceAomApplicationUpdate,
		DeleteContext: ResourceAomApplicationDelete,
		Importer: &schema.ResourceImporter{{
			StateContext: schema.ImportStatePassthroughContext,
		}},

		Timeouts: &schema.ResourceTimeout{{
			Create: schema.DefaultTimeout(5 * time.Minute),
			Update: schema.DefaultTimeout(5 * time.Minute),
			Delete: schema.DefaultTimeout(5 * time.Minute),
		}},

		Description: "schema: Internal",
		Schema: map[string]*schema.Schema{{
			"name": {{
				Type:     schema.TypeString,
				Required: true,
			}},
			"region": {{
				Type:     schema.TypeString,
				Computed: true,
			}},
			"aom_id": {{
				Type:     schema.TypeString,
				Optional: true,
				Computed: true,
			}},
			"app_id": {{
				Type:     schema.TypeString,
				Optional: true,
				Computed: true,
			}},
			"create_time": {{
				Type:     schema.TypeString,
				Computed: true,
			}},
			"creator": {{
				Type:     schema.TypeString,
				Computed: true,
			}},
			"description": {{
				Type:     schema.TypeString,
				Optional: true,
				Computed: true,
			}},
			"display_name": {{
				Type:     schema.TypeString,
				Optional: true,
				Computed: true,
			}},
			"enterprise_project_id": {{
				Type:     schema.TypeString,
				Optional: true,
				Computed: true,
			}},
			"modified_time": {{
				Type:     schema.TypeString,
				Computed: true,
			}},
			"modifier": {{
				Type:     schema.TypeString,
				Computed: true,
			}},
			"register_type": {{
				Type:     schema.TypeString,
				Optional: true,
				Computed: true,
			}},
		}},
	}}
}}

func ResourceAomApplicationCreate(ctx context.Context, d *schema.ResourceData, meta interface{{}}) diag.Diagnostics {{
	conf := meta.(*config.Config)
	client, err := httpclient_go.NewHttpClientGo(conf, "cmdb", conf.GetRegion(d))
	if err != nil {{
		return diag.Errorf("err creating Client: %s", err)
	}}

	opts := entity.BizAppParam{{
		Description:  d.Get("description").(string),
		DisplayName:  d.Get("display_name").(string),
		EpsId:        d.Get("enterprise_project_id").(string),
		Name:         d.Get("name").(string),
		RegisterType: d.Get("register_type").(string),
	}}

	client.WithMethod(httpclient_go.MethodPost).WithUrl("v1/applications").WithBody(opts)
	response, err := client.Do()
	if err != nil {{
		if strings.Contains(err.Error(), "The identifier already exists.") {{
			return getAppByName(d, meta)
		}}
		return diag.Errorf("error create Application %s: %s", opts.Name, err)
	}}
	defer response.Body.Close()
	body, err := io.ReadAll(response.Body)
	if err != nil {{
		return diag.Errorf("error convert data %s, %s", string(body), err)
	}}
	if response.StatusCode == 200 {{
		rlt := &entity.CreateModelVo{{}}
		err = json.Unmarshal(body, rlt)
		if err != nil {{
			return diag.Errorf("error convert data %s, %s", string(body), err)
		}}
		if rlt.Id == "" {{
			return diag.Errorf("error create Application %v. error: %s", opts.Name, string(body))
		}}

		d.SetId(rlt.Id)
		return ResourceAomApplicationRead(ctx, d, meta)
	}}
	return diag.Errorf("error create Application %v. error: %s", opts.Name, string(body))
}}

func ResourceAomApplicationRead(ctx context.Context, d *schema.ResourceData, meta interface{{}}) diag.Diagnostics {{
	conf := meta.(*config.Config)
	client, err := httpclient_go.NewHttpClientGo(conf, "cmdb", conf.GetRegion(d))
	if err != nil {{
		return diag.Errorf("err creating Client: %s", err)
	}}

	client.WithMethod(httpclient_go.MethodGet).WithUrl("v1/applications/" + d.Id())
	response, err := client.Do()

	body, diags := client.CheckDeletedDiag(d, err, response, "error retrieving Application")
	if body == nil {{
		return diags
	}}

	rlt := &entity.BizAppVo{{}}
	err = json.Unmarshal(body, rlt)
	if err != nil {{
		return diag.Errorf("error retrieving Application %s", d.Id())
	}}

	mErr := multierror.Append(nil,
		d.Set("aom_id", rlt.AomId),
		d.Set("app_id", rlt.AppId),
		d.Set("create_time", rlt.CreateTime),
		d.Set("creator", rlt.Creator),
		d.Set("description", rlt.Description),
		d.Set("display_name", rlt.DisplayName),
		d.Set("enterprise_project_id", rlt.EpsId),
		d.Set("modified_time", rlt.ModifiedTime),
		d.Set("modifier", rlt.Modifier),
		d.Set("name", rlt.Name),
		d.Set("register_type", rlt.RegisterType),
	)
	if err := mErr.ErrorOrNil(); err != nil {{
		return diag.Errorf("error setting Application fields: %s", err)
	}}

	return nil
}}

func ResourceAomApplicationUpdate(ctx context.Context, d *schema.ResourceData, meta interface{{}}) diag.Diagnostics {{
	conf := meta.(*config.Config)
	client, err := httpclient_go.NewHttpClientGo(conf, "cmdb", conf.GetRegion(d))
	if err != nil {{
		return diag.Errorf("err creating Client: %s", err)
	}}
	opts := entity.BizAppParam{{
		Description:  d.Get("description").(string),
		DisplayName:  d.Get("display_name").(string),
		EpsId:        d.Get("enterprise_project_id").(string),
		Name:         d.Get("name").(string),
		RegisterType: d.Get("register_type").(string),
	}}
	client.WithMethod(httpclient_go.MethodPut).WithUrl("v1/applications/" + d.Id()).WithBody(opts)
	response, err := client.Do()
	if err != nil {{
		return diag.Errorf("error update Application %s: %s", opts.Name, err)
	}}

	defer response.Body.Close()
	body, err := io.ReadAll(response.Body)
	if err != nil {{
		return diag.Errorf("error update Application %s: %s", string(body), err)
	}}

	if response.StatusCode == 200 && !strings.Contains(string(body), "error_msg") {{
		return nil
	}}

	return diag.Errorf("error update Application %s:  %s", opts.Name, string(body))
}}

func ResourceAomApplicationDelete(ctx context.Context, d *schema.ResourceData, meta interface{{}}) diag.Diagnostics {{
	conf := meta.(*config.Config)
	client, err := httpclient_go.NewHttpClientGo(conf, "cmdb", conf.GetRegion(d))
	if err != nil {{
		return diag.Errorf("err creating Client: %s", err)
	}}

	client.WithMethod(httpclient_go.MethodDelete).WithUrl("v1/applications/" + d.Id())

	response, err := client.Do()
	if err != nil {{
		return diag.Errorf("error delete Application %s: %s", d.Id(), err)
	}}

	defer response.Body.Close()
	body, err := io.ReadAll(response.Body)
	if err != nil {{
		return diag.Errorf("error delete Application %s: %s", d.Id(), err)
	}}

	if response.StatusCode == 200 && !strings.Contains(string(body), "error_msg") {{
		return nil
	}}

	return diag.Errorf("error delete Application %s:  %s", d.Id(), string(body))
}}

func getAppByName(d *schema.ResourceData, meta interface{{}}) diag.Diagnostics {{
	conf := meta.(*config.Config)
	client, err := httpclient_go.NewHttpClientGo(conf, "cmdb", conf.GetRegion(d))
	if err != nil {{
		return diag.Errorf("err creating Client: %s", err)
	}}
	path := "v1/applications?name=" + d.Get("name").(string)
	if d.Get("display_name").(string) != "" {{
		path += "&display_name=" + d.Get("display_name").(string)
	}}

	client.WithMethod(httpclient_go.MethodGet).WithUrl(path)
	response, err := client.Do()

	body, diags := client.CheckDeletedDiag(d, err, response, "error retrieving Application")
	if body == nil {{
		return diags
	}}

	rlt := &entity.BizAppVo{{}}
	err = json.Unmarshal(body, rlt)
	if err != nil {{
		return diag.Errorf("error retrieving Application %s", d.Id())
	}}
	d.SetId(rlt.AppId)
	mErr := multierror.Append(nil,
		d.Set("aom_id", rlt.AomId),
		d.Set("app_id", rlt.AppId),
		d.Set("create_time", rlt.CreateTime),
		d.Set("creator", rlt.Creator),
		d.Set("description", rlt.Description),
		d.Set("display_name", rlt.DisplayName),
		d.Set("enterprise_project_id", rlt.EpsId),
		d.Set("modified_time", rlt.ModifiedTime),
		d.Set("modifier", rlt.Modifier),
		d.Set("name", rlt.Name),
		d.Set("register_type", rlt.RegisterType),
	)
	if err := mErr.ErrorOrNil(); err != nil {{
		return diag.Errorf("error setting Application fields: %s", err)
	}}

	return nil
}}

```

output_req: {'format': 'markdown', 'language': '中文', 'description': '按条展示检查结果，并给出详细解释'}

examples: {}
